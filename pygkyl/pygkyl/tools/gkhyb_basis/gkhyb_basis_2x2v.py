"""
GK Hybrid Basis Functions - 2x2v

Configuration space: [x,z]
Phase space: [x,z,vpar,mu]

Auto-generated by gkylcas/generate_gkhyb_python.mac
Date: 2025-10-15 21:22:10-04:00
"""

import numpy as np


def gkhyb_2x_conf(i, coords):
    x, z = coords
    if   i == 0: return 1/2
    elif i == 1: return (np.sqrt(3)*x)/2
    elif i == 2: return (np.sqrt(3)*z)/2
    elif i == 3: return (3*x*z)/2
    else: raise ValueError(f"Invalid basis function index: {i}. Valid range: 0-3")

def grad_gkhyb_2x_conf(i, coords):
    x, z = coords
    if   i == 0: return np.array([0, 0])
    elif i == 1: return np.array([np.sqrt(3)/2, 0])
    elif i == 2: return np.array([0, np.sqrt(3)/2])
    elif i == 3: return np.array([(3*z)/2, (3*x)/2])
    else: raise ValueError(f"Invalid basis function index: {i}. Valid range: 0-3")


def gkhyb_2x2v_phase(i, coords):
    x, z, vpar, mu = coords
    if   i == 0: return 1/4
    elif i == 1: return (np.sqrt(3)*x)/4
    elif i == 2: return (np.sqrt(3)*z)/4
    elif i == 3: return (np.sqrt(3)*vpar)/4
    elif i == 4: return (np.sqrt(3)*mu)/4
    elif i == 5: return (3*x*z)/4
    elif i == 6: return (3*vpar*x)/4
    elif i == 7: return (3*vpar*z)/4
    elif i == 8: return (3*mu*x)/4
    elif i == 9: return (3*mu*z)/4
    elif i == 10: return (3*mu*vpar)/4
    elif i == 11: return (3**(3/2)*vpar*x*z)/4
    elif i == 12: return (3**(3/2)*mu*x*z)/4
    elif i == 13: return (3**(3/2)*mu*vpar*x)/4
    elif i == 14: return (3**(3/2)*mu*vpar*z)/4
    elif i == 15: return (9*mu*vpar*x*z)/4
    elif i == 16: return (3*np.sqrt(5)*(vpar**2-1/3))/8
    elif i == 17: return (3*np.sqrt(15)*(vpar**2*x-x/3))/8
    elif i == 18: return (3*np.sqrt(15)*(vpar**2*z-z/3))/8
    elif i == 19: return (3*np.sqrt(15)*(mu*vpar**2-mu/3))/8
    elif i == 20: return (9*np.sqrt(5)*(vpar**2*x*z-(x*z)/3))/8
    elif i == 21: return (9*np.sqrt(5)*(mu*vpar**2*x-(mu*x)/3))/8
    elif i == 22: return (9*np.sqrt(5)*(mu*vpar**2*z-(mu*z)/3))/8
    elif i == 23: return (9*np.sqrt(15)*(mu*vpar**2*x*z-(mu*x*z)/3))/8
    else: raise ValueError(f"Invalid basis function index: {i}. Valid range: 0-23")

def grad_gkhyb_2x2v_phase(i, coords):
    x, z, vpar, mu = coords
    if   i == 0: return np.array([0, 0, 0, 0])
    elif i == 1: return np.array([np.sqrt(3)/4, 0, 0, 0])
    elif i == 2: return np.array([0, np.sqrt(3)/4, 0, 0])
    elif i == 3: return np.array([0, 0, np.sqrt(3)/4, 0])
    elif i == 4: return np.array([0, 0, 0, np.sqrt(3)/4])
    elif i == 5: return np.array([(3*z)/4, (3*x)/4, 0, 0])
    elif i == 6: return np.array([(3*vpar)/4, 0, (3*x)/4, 0])
    elif i == 7: return np.array([0, (3*vpar)/4, (3*z)/4, 0])
    elif i == 8: return np.array([(3*mu)/4, 0, 0, (3*x)/4])
    elif i == 9: return np.array([0, (3*mu)/4, 0, (3*z)/4])
    elif i == 10: return np.array([0, 0, (3*mu)/4, (3*vpar)/4])
    elif i == 11: return np.array([(3**(3/2)*vpar*z)/4, (3**(3/2)*vpar*x)/4, (3**(3/2)*x*z)/4, 0])
    elif i == 12: return np.array([(3**(3/2)*mu*z)/4, (3**(3/2)*mu*x)/4, 0, (3**(3/2)*x*z)/4])
    elif i == 13: return np.array([(3**(3/2)*mu*vpar)/4, 0, (3**(3/2)*mu*x)/4, (3**(3/2)*vpar*x)/4])
    elif i == 14: return np.array([0, (3**(3/2)*mu*vpar)/4, (3**(3/2)*mu*z)/4, (3**(3/2)*vpar*z)/4])
    elif i == 15: return np.array([(9*mu*vpar*z)/4, (9*mu*vpar*x)/4, (9*mu*x*z)/4, (9*vpar*x*z)/4])
    elif i == 16: return np.array([0, 0, (3*np.sqrt(5)*vpar)/4, 0])
    elif i == 17: return np.array([(3*np.sqrt(15)*(vpar**2-1/3))/8, 0, (3*np.sqrt(15)*vpar*x)/4, 0])
    elif i == 18: return np.array([0, (3*np.sqrt(15)*(vpar**2-1/3))/8, (3*np.sqrt(15)*vpar*z)/4, 0])
    elif i == 19: return np.array([0, 0, (3*np.sqrt(15)*mu*vpar)/4, (3*np.sqrt(15)*(vpar**2-1/3))/8])
    elif i == 20: return np.array([(9*np.sqrt(5)*(vpar**2*z-z/3))/8, (9*np.sqrt(5)*(vpar**2*x-x/3))/8, (9*np.sqrt(5)*vpar*x*z)/4, 0])
    elif i == 21: return np.array([(9*np.sqrt(5)*(mu*vpar**2-mu/3))/8, 0, (9*np.sqrt(5)*mu*vpar*x)/4, (9*np.sqrt(5)*(vpar**2*x-x/3))/8])
    elif i == 22: return np.array([0, (9*np.sqrt(5)*(mu*vpar**2-mu/3))/8, (9*np.sqrt(5)*mu*vpar*z)/4, (9*np.sqrt(5)*(vpar**2*z-z/3))/8])
    elif i == 23: return np.array([(9*np.sqrt(15)*(mu*vpar**2*z-(mu*z)/3))/8, (9*np.sqrt(15)*(mu*vpar**2*x-(mu*x)/3))/8, (9*np.sqrt(15)*mu*vpar*x*z)/4, (9*np.sqrt(15)*(vpar**2*x*z-(x*z)/3))/8])
    else: raise ValueError(f"Invalid basis function index: {i}. Valid range: 0-23")


def num_basis_2x_conf():
    """Return number of 2x configuration space basis functions."""
    return 4


def num_basis_2x2v_phase():
    """Return number of 2x2v phase space basis functions."""
    return 24


# Legacy function names for backwards compatibility
def num_basis_conf():
    """Return number of configuration space basis functions."""
    return num_basis_2x_conf()


def num_basis_phase():
    """Return number of phase space basis functions."""
    return num_basis_2x2v_phase()


def eval_all_conf(coords):
    """Evaluate all configuration space basis functions at given coordinates."""
    return np.array([gkhyb_2x_conf(i, coords) for i in range(4)])


def eval_all_phase(coords):
    """Evaluate all phase space basis functions at given coordinates."""
    return np.array([gkhyb_2x2v_phase(i, coords) for i in range(24)])

def weak_mult_2x_ser_p1(f, g):
    shape = f.shape
    for cidx in np.ndindex(shape[:-1]):
        f[cidx] = weak_mult_2x_ser_p1_kernel(f[cidx], g[cidx])

def weak_mult_2x2v_gkhyb_p1(f, g):
    shape = f.shape
    for cidx in np.ndindex(shape[:-1]):
        f[cidx] = weak_mult_2x2v_gkhyb_p1_kernel(f[cidx], g[cidx])

def weak_mult_2x_ser_p1_kernel(f, g):
    c = 0.5  # 1/sqrt(4)
    
    tmp = np.zeros(4)
    tmp[0] = c*f[3]*g[3]+c*g[0]*f[0]+c*f[2]*g[2]+c*g[1]*f[1]
    tmp[1] = c*f[3]*g[2]+c*g[0]*f[1]+c*f[2]*g[3]+c*g[1]*f[0]
    tmp[2] = c*g[2]*f[0]+c*g[1]*f[3]+c*f[2]*g[0]+c*g[3]*f[1]
    tmp[3] = c*g[0]*f[3]+c*g[2]*f[1]+c*f[2]*g[1]+c*g[3]*f[0]
    
    return tmp


def weak_mult_2x2v_gkhyb_p1_kernel(f, g):
    c = 0.5  # 1/sqrt(4)
    
    tmp = np.zeros(24)
    tmp[0] = c*f[3]*g[5]+c*f[2]*g[2]+c*f[1]*g[1]+c*f[0]*g[0]
    tmp[1] = c*f[2]*g[5]+c*g[2]*f[3]+c*f[0]*g[1]+c*g[0]*f[1]
    tmp[2] = c*f[1]*g[5]+c*g[1]*f[3]+c*f[0]*g[2]+c*g[0]*f[2]
    tmp[3] = c*f[3]*g[11]+c*f[2]*g[7]+c*f[1]*g[6]+c*f[0]*g[3]
    tmp[4] = c*f[3]*g[12]+c*f[2]*g[9]+c*f[1]*g[8]+c*f[0]*g[4]
    tmp[5] = c*f[0]*g[5]+c*g[0]*f[3]+c*f[1]*g[2]+c*g[1]*f[2]
    tmp[6] = c*f[2]*g[11]+c*f[3]*g[7]+c*f[0]*g[6]+c*f[1]*g[3]
    tmp[7] = c*f[1]*g[11]+c*f[0]*g[7]+c*f[3]*g[6]+c*f[2]*g[3]
    tmp[8] = c*f[2]*g[12]+c*f[3]*g[9]+c*f[0]*g[8]+c*f[1]*g[4]
    tmp[9] = c*f[1]*g[12]+c*f[0]*g[9]+c*f[3]*g[8]+c*f[2]*g[4]
    tmp[10] = c*f[3]*g[15]+c*f[2]*g[14]+c*f[1]*g[13]+c*f[0]*g[10]
    tmp[11] = c*f[0]*g[11]+c*f[1]*g[7]+c*f[2]*g[6]+c*f[3]*g[3]
    tmp[12] = c*f[0]*g[12]+c*f[1]*g[9]+c*f[2]*g[8]+c*f[3]*g[4]
    tmp[13] = c*f[2]*g[15]+c*f[3]*g[14]+c*f[0]*g[13]+c*f[1]*g[10]
    tmp[14] = c*f[1]*g[15]+c*f[0]*g[14]+c*f[3]*g[13]+c*f[2]*g[10]
    tmp[15] = c*f[0]*g[15]+c*f[1]*g[14]+c*f[2]*g[13]+c*f[3]*g[10]
    tmp[16] = c*f[3]*g[20]+c*f[2]*g[18]+c*f[1]*g[17]+c*f[0]*g[16]
    tmp[17] = c*f[2]*g[20]+c*f[3]*g[18]+c*f[0]*g[17]+c*f[1]*g[16]
    tmp[18] = c*f[1]*g[20]+c*f[0]*g[18]+c*f[3]*g[17]+c*f[2]*g[16]
    tmp[19] = c*f[3]*g[23]+c*f[2]*g[22]+c*f[1]*g[21]+c*f[0]*g[19]
    tmp[20] = c*f[0]*g[20]+c*f[1]*g[18]+c*f[2]*g[17]+c*f[3]*g[16]
    tmp[21] = c*f[2]*g[23]+c*f[3]*g[22]+c*f[0]*g[21]+c*f[1]*g[19]
    tmp[22] = c*f[1]*g[23]+c*f[0]*g[22]+c*f[3]*g[21]+c*f[2]*g[19]
    tmp[23] = c*f[0]*g[23]+c*f[1]*g[22]+c*f[2]*g[21]+c*f[3]*g[19]
    
    return tmp


if __name__ == "__main__":
    # Example usage
    print(f"GK Hybrid Basis 2x2v")
    print(f"Configuration space basis functions: {num_basis_conf()}")
    print(f"Phase space basis functions: {num_basis_phase()}")
    print() 
