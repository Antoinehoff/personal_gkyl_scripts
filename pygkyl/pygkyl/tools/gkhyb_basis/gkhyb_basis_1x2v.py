"""
GK Hybrid Basis Functions - 1x2v

Configuration space: [x]
Phase space: [x,vpar,mu]

Auto-generated by gkylcas/generate_gkhyb_python.mac
Date: 2025-10-15 21:22:10-04:00
"""

import numpy as np


def gkhyb_1x_conf(i, coords):
    """
    GK Hybrid basis function evaluation.
    
    Parameters:
    -----------
    i : int
        Basis function index (0 to 1)
    coords : tuple or array
        Coordinates (x)
    
    Returns:
    --------
    float
        Value of basis function φ[i] at the given coordinates
    """
    x = coords[0] if hasattr(coords, '__len__') else coords
    
    if   i == 0: return 1/np.sqrt(2)
    elif i == 1: return (np.sqrt(3)*x)/np.sqrt(2)
    else: raise ValueError(f"Invalid basis function index: {i}. Valid range: 0-1")

def grad_gkhyb_1x_conf(i, coords):
    """
    Gradient of basis function φ[i] as numpy array.
    Returns: numpy array of shape (1,)
    """
    x = coords[0] if hasattr(coords, '__len__') else coords
    
    if   i == 0: return np.array([0])
    elif i == 1: return np.array([np.sqrt(3)/np.sqrt(2)])
    else: raise ValueError(f"Invalid basis function index: {i}. Valid range: 0-1")


def gkhyb_1x2v_phase(i, coords):
    """
    GK Hybrid basis function evaluation.
    
    Parameters:
    -----------
    i : int
        Basis function index (0 to 11)
    coords : tuple or array
        Coordinates (x, vpar, mu)
    
    Returns:
    --------
    float
        Value of basis function φ[i] at the given coordinates
    """
    x, vpar, mu = coords
    
    if   i == 0: return 1/2**(3/2)
    elif i == 1: return (np.sqrt(3)*x)/2**(3/2)
    elif i == 2: return (np.sqrt(3)*vpar)/2**(3/2)
    elif i == 3: return (np.sqrt(3)*mu)/2**(3/2)
    elif i == 4: return (3*vpar*x)/2**(3/2)
    elif i == 5: return (3*mu*x)/2**(3/2)
    elif i == 6: return (3*mu*vpar)/2**(3/2)
    elif i == 7: return (3**(3/2)*mu*vpar*x)/2**(3/2)
    elif i == 8: return (3*np.sqrt(5)*(vpar**2-1/3))/2**(5/2)
    elif i == 9: return (3*np.sqrt(15)*(vpar**2*x-x/3))/2**(5/2)
    elif i == 10: return (3*np.sqrt(15)*(mu*vpar**2-mu/3))/2**(5/2)
    elif i == 11: return (9*np.sqrt(5)*(mu*vpar**2*x-(mu*x)/3))/2**(5/2)
    else: raise ValueError(f"Invalid basis function index: {i}. Valid range: 0-11")

def grad_gkhyb_1x2v_phase(i, coords):
    """
    Gradient of basis function φ[i] as numpy array.
    Returns: numpy array of shape (3,)
    """
    x, vpar, mu = coords
    
    if   i == 0: return np.array([0, 0, 0])
    elif i == 1: return np.array([np.sqrt(3)/2**(3/2), 0, 0])
    elif i == 2: return np.array([0, np.sqrt(3)/2**(3/2), 0])
    elif i == 3: return np.array([0, 0, np.sqrt(3)/2**(3/2)])
    elif i == 4: return np.array([(3*vpar)/2**(3/2), (3*x)/2**(3/2), 0])
    elif i == 5: return np.array([(3*mu)/2**(3/2), 0, (3*x)/2**(3/2)])
    elif i == 6: return np.array([0, (3*mu)/2**(3/2), (3*vpar)/2**(3/2)])
    elif i == 7: return np.array([(3**(3/2)*mu*vpar)/2**(3/2), (3**(3/2)*mu*x)/2**(3/2), (3**(3/2)*vpar*x)/2**(3/2)])
    elif i == 8: return np.array([0, (3*np.sqrt(5)*vpar)/2**(3/2), 0])
    elif i == 9: return np.array([(3*np.sqrt(15)*(vpar**2-1/3))/2**(5/2), (3*np.sqrt(15)*vpar*x)/2**(3/2), 0])
    elif i == 10: return np.array([0, (3*np.sqrt(15)*mu*vpar)/2**(3/2), (3*np.sqrt(15)*(vpar**2-1/3))/2**(5/2)])
    elif i == 11: return np.array([(9*np.sqrt(5)*(mu*vpar**2-mu/3))/2**(5/2), (9*np.sqrt(5)*mu*vpar*x)/2**(3/2), (9*np.sqrt(5)*(vpar**2*x-x/3))/2**(5/2)])
    else: raise ValueError(f"Invalid basis function index: {i}. Valid range: 0-11")


def num_basis_1x_conf():
    """Return number of 1x configuration space basis functions."""
    return 2


def num_basis_1x2v_phase():
    """Return number of 1x2v phase space basis functions."""
    return 12


# Legacy function names for backwards compatibility
def num_basis_conf():
    """Return number of configuration space basis functions."""
    return num_basis_1x_conf()


def num_basis_phase():
    """Return number of phase space basis functions."""
    return num_basis_1x2v_phase()


def eval_all_conf(coords):
    """Evaluate all configuration space basis functions at given coordinates."""
    return np.array([gkhyb_1x_conf(i, coords) for i in range(2)])


def eval_all_phase(coords):
    """Evaluate all phase space basis functions at given coordinates."""
    return np.array([gkhyb_1x2v_phase(i, coords) for i in range(12)])


if __name__ == "__main__":
    # Example usage
    print(f"GK Hybrid Basis 1x2v")
    print(f"Configuration space basis functions: {num_basis_conf()}")
    print(f"Phase space basis functions: {num_basis_phase()}")
    print()
    
    # Evaluate at a test point
    x_test = [0.5]
    phase_test = [0.5, 1.0, 0.5]  # x, vpar, mu
    
    print("Configuration space basis at x=0.5:")
    conf_vals = eval_all_conf(x_test)
    for i, val in enumerate(conf_vals):
        print(f"  φ[{i}] = {val:.6f}")
    print()
    
    print("Phase space basis at (x, vpar, mu) = (0.5, 1.0, 0.5):")
    phase_vals = eval_all_phase(phase_test)
    for i, val in enumerate(phase_vals):
        print(f"  φ[{i}] = {val:.6f}")
